## Сборка и запуск

1) Для установки зависимостей в корне репозитория набрать 'npm install'
2) Собрать код в один файл 'npm run bundle'
3) Тестировать код с помощью автотестов - набрать 'npm run test'

## Ход выполнения и комментарии

Сборка была Webpack и открывала окно в браузере. Потом я столкнулась с тем, что он дописывает экспорты и кэширование модулей, 
из-за чего тесты даже не видят целевой функции на выходе. Переписала под rollup, он ничего лишнего не оставляет. 
Сейчас вызвать и протестировать код можно через тестовый файл.


В качестве линтера - ESlint в конфиге airbnb с небольшими изменениями. Мне в целом нравится стайлгайд airbnb, но не 
нравятся висячие запятые, лишние скобки в стрелочных функциях и еще пара вещей, поэтому подстраиваю их.


Для тестирования jest. Он прост в разворачивании и использовании, благо семпл данных есть и никаких глобальных 
пресетов для тестирования делать не надо.
С ним тестирую output, еще логирую время выполнения функций - там же, в тестовом файле.

### Структура проекта

Весь проект реализован на функциях. Основная логика лежит в index.ts. Здесь главная функция prepareData (as per specs) и 
функции по обработке отдельных слайдов. Я исходила из формата выходных данных, и мне показалось логичным изолировать 
фрагменты кода, ответственные за каждый слайд, в отдельные функции. Эти функции названы с префиксом prepare-, по 
аналогии с основной - за одним исключением.


Для обработки алиасов leaders и vote одна функция rankUsers, потому что логика и формат выходных данных 
у них абсолютно идентичны, это позволяет переиспользовать код. 
Она же генерит список юзеров для chart (массив абсолютно идентичен leaders, это одна переменная).
У chart, diagram и activity по собственной функции. Отдельным файлом helpers.ts вынесены хелперы (функции сортировки, 
фильтрации, подстановки окончаний слов в легенду и тд) - тот код, который можно изолировать и переиспользовать для разных слайдов.


Получаемый на входе массив я сначала сортирую по сущностям, чтобы не итерироваться каждый раз по 100,000 объектам. 
Мы не работаем с issues и projects, поэтому их не включаю (но если появится слайд, который их использует, достаточно 
будет строчку дописать и извлечь их). Потом сущности, которые можно отнести к текущему спринту, 
фильтрую в отдельную переменную. С этими двумя дальше и работаю.

### Сложность и скорость

Максимальная сложность, которую встречаем - это n*log(n) в rankUsers, там сортировка. 
Остальные максимум n (filter, map, forEach, reduce, find/findIndex, for-циклы). 
Функцию, которая сортирует входной массив по сущностям, я реализовала максимум за одну проходку, помня о большом объеме 
входных данных. Чтобы кешировать функции фильтрации и сортировки, к которым мы обращаемся несколько раз, написала функцию 
мемоизации. 

Замер скорости при тесте дает около 1500-1900ms для наполненного спринта, 20-40ms для пустого.
