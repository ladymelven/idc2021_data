## Сборка и запуск

1) Для установки зависимостей в корне репозитория набрать 'npm install'
2) Поднять тестовый сервер (я тестировала через браузер) - набрать 'npm run start'
3) Собрать оптимизированный билд - набрать 'npm run build'
4) Тестировать код с помощью автотестов - набрать 'npm run test'

## Ход выполнения и комментарии

Дисклеймер: у меня больше верстальная работа, это самый большой на сегодня проект, который я написала на ~~Js~~ Ts (если 
не считать пет-проектов с буткемпа на React и Vue, именно на ванильном). Я посмотрела, как заботливо вы положили в задание 
все типы, и решила, что грех не использовать такую возможность научиться. Примерно такая же ситуация с тестированием: еще не
приходилось иметь дело с достаточно большой (и достаточно долго поддерживаемой) кодбазой, чтобы нужны были тесты. Возможно,
подход у меня во многом дилетантский. Но стараюсь.


Сборка - Webpack, взяла старый бойлерплейт и подстроила под TypeScript.
В качестве линтера - ESlint в конфиге airbnb с моими подстройками. Дело личного вкуса: мне симпатизирует airbnb, но ненавижу
висячие запятые =)
Для тестирования jest. Он простой, бесконфигный и прекрасный, на 100% закрывает мои скромные нужды в ассертах.

### Структура проекта

Entry point - index.ts. Он делает ровно то, что принимает на вход нужную нам функцию и отдает. На разработке он еще ее вызывал.
Собственно, он существует в основном потому, что в задании нужен синтаксис commonJs, а я не хотела отказываться от импортов 
ES Modules с деструктуризацией. 


Основная логика лежит в app/prepare.ts. Здесь головная функция prepareData (as per task description) и функции по обработке
отдельных слайдов. Для обработки алиасов leaders и vote одна функция rankUsers, потому что логика и формат выходных данных 
у них абсолютно идентичен. У остальных трех алиасов по собственной функции плюс хелперы, которые живут отдельным файлом в 
той же директории, что и prepare.ts.


### Сложность и скорость

Самая высокая сложность, которую встречаем - это n*log(n) в rankUsers, там сортировка. Реализовать сортировку с меньшей big O 
я не умею. Остальные максимум n. Функцию, которая сортирует входной массив по сущностям, я реализовала максимум за одну 
проходку, памятуя большой объем входных данных. Чтобы кешировать функции фильтрации и сортировки, к которым мы обращаемся 
несколько раз, написала функцию мемоизации. Замер скорости для браузера показывает +-950ms на выполнение функции
для данного семпла данных и спринта 977 (до мемоизации было ~1150).


В нескольких сортировках и фильтрациях есть краевые ситуации: например, при равенстве целевых значений у юзеров в карточках 
vote и leaders (тогда я сортирую по id) и когда в диаграмме не изменилось количество коммитов в целом или в разбивке (тогда
для целого вывожу "как и в прошлом спринте", для разбивки "=="). В эфире с ответами на вопросы был ответ, что при равенстве
дополнительно сортировать не надо, но тесты и эталон выходных данных говорят иное: в leaders Николаичев идет перед 
Фроловым при одинаковом количестве коммитов, при том что во входном массиве Фролов встречается раньше.
