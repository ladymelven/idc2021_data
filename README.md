## Сборка и запуск

1) Для установки зависимостей в корне репозитория набрать 'npm install'
2) Поднять тестовый сервер (я тестировала через браузер) - набрать 'npm run start'
3) Собрать оптимизированный билд - набрать 'npm run build'
4) Тестировать код с помощью автотестов - набрать 'npm run test'

## Ход выполнения и комментарии

Дисклеймер: у меня больше верстальная работа, это самый большой на сегодня проект, который я написала на ~~Js~~ Ts (если 
не считать пет-проектов с буткемпа на React и Vue, именно на ванильном). Я посмотрела, как заботливо вы положили в задание 
все типы, и решила, что грех не использовать такую возможность научиться. Примерно такая же ситуация с тестированием: еще не
приходилось иметь дело с достаточно большой (и достаточно долго поддерживаемой) кодбазой, чтобы нужны были тесты. Возможно,
подход у меня во многом дилетантский. Но стараюсь.


Сборка была Webpack, потом я столкнулась с тем, что он даже без бабеля транспилит мой код, из-за тесты даже не видят экспорта.
Переписала под rollup, он ничего лишнего не оставляет.
В качестве линтера - ESlint в конфиге airbnb с моими подстройками. Дело личного вкуса: мне симпатизирует airbnb, но ненавижу
висячие запятые =)
Для тестирования jest. Он простой, бесконфигный и прекрасный, на 100% закрывает мои скромные нужды. Благо семпл данных для
тестирования приложен к заданию и не надо ничего генерировать.

### Структура проекта

Entry point - index.ts. Он делает ровно то, что принимает на вход нужную нам функцию и отдает. Собственно, он существует 
в основном потому, что в задании нужен синтаксис экспорта commonJs, а я не хотела отказываться от импортов ES Modules с 
деструктуризацией. 


Основная логика лежит в app/prepare.ts. Здесь головная функция prepareData (as per specs) и функции по обработке
отдельных слайдов. Для обработки алиасов leaders и vote одна функция rankUsers, потому что логика и формат выходных данных 
у них абсолютно идентичен. Она же генерит список юзеров для chart (массив абсолютно идентичен leader, это одна переменная).
У остальных трех алиасов по собственной функции плюс хелперы (функции сортировки, фильтрации, подстановки окончаний в 
легенды и тд), которые живут отдельным файлом в той же директории, что и prepare.ts.


### Сложность и скорость

Самая высокая сложность, которую встречаем - это n*log(n) в rankUsers, там сортировка. Остальные максимум n. 
Функцию, которая сортирует входной массив по сущностям, я реализовала максимум за одну проходку, памятуя большой объем 
входных данных. Чтобы кешировать функции фильтрации и сортировки, к которым мы обращаемся несколько раз, написала функцию 
мемоизации. Замер скорости на тестах дает около 1500ms. Очень большой разброс по скорости (намерила и 800ms, и 1900), 
не могу сказать, с чем связано.


В нескольких сортировках и фильтрациях есть краевые ситуации: например, при равенстве целевых значений у юзеров в карточках 
vote и leaders (тогда я сортирую по id) и когда в диаграмме не изменилось количество коммитов в целом или в разбивке (тогда
для целого вывожу "как и в прошлом спринте", для разбивки "=="). В эфире с ответами на вопросы был ответ, что при равенстве
дополнительно сортировать не надо, но тесты и эталон выходных данных говорят иное: в leaders Николаичев идет перед 
Фроловым при одинаковом количестве коммитов, при том что во входном массиве Фролов встречается раньше.
